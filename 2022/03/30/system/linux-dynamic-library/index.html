<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"solotzg.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"manual","top_n_per_article":5,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="PingCAP（aka 贵司）自研了套部署工具 TiUP 来取代早前使用的重型部署工具 Ansible。然而实际使用时，TiFlash 节点在打 patch 过程中出现过不符合预期的报错。后来发现，TiUP 打 patch 的操作并没有停进程，而是直接 tar 命令解压覆盖部署目录，原子性保障也是无从谈起。v6.0 版本前 TiFlash 部分模块包含动态加载 共享库（aka 动态库）的行为，这类">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 动态链接库相关整理">
<meta property="og:url" content="https://solotzg.github.io/2022/03/30/system/linux-dynamic-library/index.html">
<meta property="og:site_name" content="SOLOTZG">
<meta property="og:description" content="PingCAP（aka 贵司）自研了套部署工具 TiUP 来取代早前使用的重型部署工具 Ansible。然而实际使用时，TiFlash 节点在打 patch 过程中出现过不符合预期的报错。后来发现，TiUP 打 patch 的操作并没有停进程，而是直接 tar 命令解压覆盖部署目录，原子性保障也是无从谈起。v6.0 版本前 TiFlash 部分模块包含动态加载 共享库（aka 动态库）的行为，这类">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-03-30T08:04:36.000Z">
<meta property="article:modified_time" content="2022-06-13T07:21:32.790Z">
<meta property="article:author" content="TONG, Zhigao">
<meta property="article:tag" content="PingCAP">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Compiler">
<meta property="article:tag" content="System">
<meta property="article:tag" content="FileSystem">
<meta property="article:tag" content="DynamicLibrary">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://solotzg.github.io/2022/03/30/system/linux-dynamic-library/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://solotzg.github.io/2022/03/30/system/linux-dynamic-library/","path":"2022/03/30/system/linux-dynamic-library/","title":"Linux 动态链接库相关整理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux 动态链接库相关整理 | SOLOTZG</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SOLOTZG</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">Linux 文件系统基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Inode"><span class="nav-number">1.1.</span> <span class="nav-text">Inode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Inode-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="nav-number">1.1.1.</span> <span class="nav-text">Inode 深入分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cp-x2F-rm-x2F-mv-x2F-tar-%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.</span> <span class="nav-text">cp&#x2F;rm&#x2F;mv&#x2F;tar 命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">2.</span> <span class="nav-text">Linux 动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">2.1.</span> <span class="nav-text">链接动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%881%EF%BC%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">案例（1）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">分析（1）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E7%AC%A6%E5%8F%B7%E5%86%B2%E7%AA%81"><span class="nav-number">2.1.2.</span> <span class="nav-text">解决符号冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%8A%A0%E8%BD%BD%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">显式加载（运行时加载）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E9%9A%90%E8%97%8F"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">符号隐藏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">2.2.</span> <span class="nav-text">替换动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%882%EF%BC%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">案例（2）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90%EF%BC%882%EF%BC%89"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">分析（2）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80"><span class="nav-number">2.3.</span> <span class="nav-text">动态库性能开销</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%883%EF%BC%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">案例（3）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">2.4.</span> <span class="nav-text">共享库兼容性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%884%EF%BC%89"><span class="nav-number">2.4.1.</span> <span class="nav-text">案例（4）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%885%EF%BC%89"><span class="nav-number">2.4.2.</span> <span class="nav-text">案例（5）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%886%EF%BC%89"><span class="nav-number">2.4.3.</span> <span class="nav-text">案例（6）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90%EF%BC%886%EF%BC%89"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">分析（6）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93-or-%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-number">2.5.</span> <span class="nav-text">动态库 or 静态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%887%EF%BC%89"><span class="nav-number">2.5.1.</span> <span class="nav-text">案例（7）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90%EF%BC%887%EF%BC%89"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">分析（7）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text">Linux 静态库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">静态库冲突问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%888%EF%BC%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">案例（8）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90%EF%BC%888%EF%BC%89"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">分析（8）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%888%EF%BC%89"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">解决方案（8）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%86%B2%E7%AA%81%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="nav-number">3.1.1.2.1.</span> <span class="nav-text">删除冲突的符号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%AC%A6%E5%8F%B7%E5%90%8D%E7%A7%B0"><span class="nav-number">3.1.1.2.2.</span> <span class="nav-text">修改符号名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%86%B2%E7%AA%81%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.1.2.3.</span> <span class="nav-text">修改冲突符号的类型</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO"><span class="nav-number">4.</span> <span class="nav-text">TODO</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TONG, Zhigao"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">TONG, Zhigao</p>
  <div class="site-description" itemprop="description">Blogs</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/solotzg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;solotzg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:solotzg@gmail.com" title="E-Mail → mailto:solotzg@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://solotzg.github.io/2022/03/30/system/linux-dynamic-library/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="TONG, Zhigao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SOLOTZG">
      <meta itemprop="description" content="Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux 动态链接库相关整理 | SOLOTZG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux 动态链接库相关整理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-30 16:04:36" itemprop="dateCreated datePublished" datetime="2022-03-30T16:04:36+08:00">2022-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-13 15:21:32" itemprop="dateModified" datetime="2022-06-13T15:21:32+08:00">2022-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/System/" itemprop="url" rel="index"><span itemprop="name">System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>PingCAP（aka <code>贵司</code>）自研了套部署工具 <a target="_blank" rel="noopener" href="https://github.com/pingcap/tiup">TiUP</a> 来取代早前使用的重型部署工具 <a target="_blank" rel="noopener" href="https://github.com/ansible/ansible">Ansible</a>。然而实际使用时，TiFlash 节点在打 patch 过程中出现过不符合预期的报错。后来发现，TiUP 打 patch 的操作并没有停进程，而是直接 <code>tar</code> 命令解压覆盖部署目录，原子性保障也是无从谈起。v6.0 版本前 TiFlash 部分模块包含动态加载 <code>共享库</code>（aka <code>动态库</code>）的行为，这类行为会被搜索路径下的库文件影响。如果存在某个时刻引入的模块相互不兼容，则直接影响程序的行为。</p>
<p>因为是用 <code>tar</code> 命令解压覆盖，反而没有出现老生常谈的 <code>cp</code> 覆盖动态库引起 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Segmentation_fault">Segmentation fault</a> 的问题。</p>
<p>正好借此整理下相关的几个问题：</p>
<ul>
<li>cp &#x2F; tar 命令是如何工作的？</li>
<li>cp 覆盖正在被使用的动态库为何会引发异常？</li>
<li>使用动态库要避开哪些坑？</li>
<li>动态库有哪些额外的开销？</li>
</ul>
<span id="more"></span>

<h1 id="Linux-文件系统基础"><a href="#Linux-文件系统基础" class="headerlink" title="Linux 文件系统基础"></a>Linux 文件系统基础</h1><p>相关基础参考 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Modern_Operating_Systems">Modern Operating Systems</a>，<a target="_blank" rel="noopener" href="https://www.science.smith.edu/~nhowe/teaching/csc262/oldlabs/ext2.html">The Ext2 Filesystem</a>，<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/filesystems/index.html">kernel.org&#x2F;doc&#x2F;filesystems</a>，深度细节建议看操作系统代码实现。</p>
<h2 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h2><p>Linux 下 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inode">Inode(Index node)</a> 是一个重要概念，是理解 Unix&#x2F;Linux 文件系统和硬盘储存的基础。Inode、软链接、硬链接 等入门基础可以参考 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2011/12/inode.html">阮一峰. 理解inode</a>，解释得比较易懂。以下部分做点补充。</p>
<hr>
<p>Inode 本身是一种抽象设计，不同操作系统有各自实现，此处针对传统的类 Unix 文件系统。</p>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做 <code>扇区（Sector）</code>，每个扇区大小为 512B。操作系统存取文件的最小单位是 <code>块（Block）</code>，一般为连续 8 个扇区。文件数据存储在块中，Inode 则作为索引节点存储文件的元信息：Inode 号码，文件字节数、User ID、Group ID、读｜写｜执行权限、3 个时间戳（Inode 上次变动时间，文件数据上次变动时间，文件上次打开时间）、链接数（硬链接）、数据 Block 位置。详细定义可参考 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/inode.7.html">linux&#x2F;man-pages&#x2F;inode</a>。</p>
<p>Inode 大小（通常为 256B）和数量在格式化时给定。通过命令获取某块 3.6T 硬盘的 <code>Inode size</code> 值为 256B，其 Inode 区存储上限是 233M。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs -h /dev/<span class="variable">$&#123;disk&#125;</span> | grep -E <span class="string">&quot;Inode size|Block size&quot;</span></span><br><span class="line"></span><br><span class="line">Block size:               4096</span><br><span class="line">Inode size:               256</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hi /dev/<span class="variable">$&#123;disk&#125;</span></span><br><span class="line"></span><br><span class="line">Filesystem     Inodes IUsed IFree IUse% Mounted on</span><br><span class="line">....           233M    33M  201M   14%  ....</span><br></pre></td></tr></table></figure>

<p>由此推算出，该硬盘最多存储 953888 个 Inode。假设每个 Inode 对应一个 4K 大小的独立目录，总容量也不超过 3.65G。所以确实会出现因 Inode 耗尽而无法创建文件的极端情况。</p>
<hr>
<p><em><strong>TiFlash 存储模块也险些暴露出来类似问题</strong></em></p>
<ul>
<li>早前版本中，TiFlash 的 schema sync 逻辑会把 TiDB 的每张物理表都在本地建立对应的文件夹以及 schema 相关的文件</li>
<li>倘若表的数量过多，超过磁盘 Inode 承载的上限，则会导致系统不可用</li>
</ul>
<hr>
<p>Inode 在同个文件系统内保证唯一，在不同文件系统中互不依赖，存在 2 个不同磁盘上的文件 Inode 号码相同的情况。通过 Inode 号码直接删除 Inode 节点，等同于删除文件。当文件被删除后，Inode 会被系统回收再分配。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -i</span><br><span class="line"></span><br><span class="line"> 134610994 anaconda-post.log  1320256620 dev   134611301 home   134611303 lib64   146932813 misc   148638932 opt    148768809 root   134611337 sbin           1 sys   148768954 usr</span><br><span class="line"> 134610995 bin		       148635658 etc   134611302 lib    134611304 media   134611305 mnt            1 proc   148768952 run    134611338 srv    148768953 tmp   148772892 var</span><br><span class="line"></span><br><span class="line">find . -inum 134610994 -delete</span><br></pre></td></tr></table></figure>

<hr>
<p>Unix&#x2F;Linux 系统中，目录（directory）也是一种文件：</p>
<ul>
<li>创建目录时，默认会生成两个目录项：<code>.</code> 和 <code>..</code>。</li>
<li>前者的 Inode 号码就是当前目录的 Inode 号码，等同于当前目录的 <code>硬链接</code>，也就使得新建空目录的链接数加 1 等于 2。</li>
<li>后者的 Inode 号码就是当前目录的父目录的 Inode 号码，等同于父目录的硬链接，令父目录的 <code>链接数</code> 加 1。</li>
<li>对于 ‘&#x2F;‘ 目录，则两者都指向自己。</li>
<li>系统目录的 Inode 为特定项（Inode Number: 1），一般根据挂载顺序 ‘&#x2F;‘ 目录的 Inode Number 为 2。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> /</span><br><span class="line"></span><br><span class="line">  File: ‘/’</span><br><span class="line">  Size: 4096            Blocks: 8          IO Block: 4096   directory</span><br><span class="line">Device: 803h/2051d      Inode: 2           Links: 26</span><br><span class="line">Access: (0555/dr-xr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-04-23 16:41:30.312343163 +0800</span><br><span class="line">Modify: 2022-04-21 17:17:40.483912721 +0800</span><br><span class="line">Change: 2022-04-21 17:17:40.483912721 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"> </span><br><span class="line"><span class="built_in">ls</span> -ai / | grep <span class="string">&quot; 1 &quot;</span></span><br><span class="line"></span><br><span class="line">       1 proc</span><br><span class="line">       1 sys</span><br></pre></td></tr></table></figure>

<p>硬链接的目标和源共用同个 Inode，因此不能跨盘建立，否则报错 <code>Invalid cross-device link</code>。通过 <code>ln $&#123;src&#125; $&#123;tar&#125;</code> 建立硬链接无法作用于目录，否则报错 <code>hard link not allowed for directory</code>。</p>
<p>硬链接自身就是文件系统中的一环，链接数归 0 后系统才会尝试回收对应的文件，与引用计数的管理策略类似。如果目录可以建立硬链接，则容易造成循环引用，导致文件无法回收。与硬链接不同，软链接就是个独立的二进制文件，使用时再通过文件系统解析到对应的目标，如果失败则会返回错误。也就意味着软链接不会对文件系统本身产生侵入性影响。</p>
<h3 id="Inode-深入分析"><a href="#Inode-深入分析" class="headerlink" title="Inode 深入分析"></a>Inode 深入分析</h3><p>以 ext4 文件系统为例，硬盘格式化的时候，操作系统将其划分为多个 <code>Block Group</code></p>
<ul>
<li>Group 0 前面预留 1024 字节，可用于安装 x86 引导扇区。</li>
</ul>
<table>
<thead>
<tr>
<th>Group 0 Padding</th>
<th>Block Group 0</th>
<th>Block Group 1</th>
<th>…</th>
<th>Block Group N</th>
</tr>
</thead>
<tbody><tr>
<td>1024 bytes</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Block Group 的布局大致如下</li>
</ul>
<table>
<thead>
<tr>
<th>ext4 Super Block</th>
<th>Group Descriptors</th>
<th>Reserved GDT Blocks</th>
<th>Data Block Bitmap</th>
<th>inode Bitmap</th>
<th>inode Table</th>
<th>Data Blocks</th>
</tr>
</thead>
<tbody><tr>
<td>1 block</td>
<td>N blocks</td>
<td>N blocks</td>
<td>1 block</td>
<td>1 block</td>
<td>N blocks</td>
<td>N blocks</td>
</tr>
</tbody></table>
<p>参考 <a target="_blank" rel="noopener" href="https://docs.huihoo.com/doxygen/linux/kernel/3.7/structext4__super__block.html">struct ext4_super_block</a> 以及 <a target="_blank" rel="noopener" href="https://docs.huihoo.com/doxygen/linux/kernel/3.7/structext4__inode.html">struct ext4_inode</a></p>
<ul>
<li>每个 Block Group 包含 <code>s_blocks_per_group</code> 个 Block，即 <code>8 * block_size_in_bytes</code>（Bitmap 大小为 <code>block_size_in_bytes</code>，最多可以表示的位数 <code>8 * block_size_in_bytes</code>）。</li>
<li><code>s_inodes_per_group</code> 表示每个 Block Group 中 Inode 的数量。</li>
<li>已知某个文件的 Inode 号码 为 <em>inum</em>，则查找文件内容的过程为：<ul>
<li><code>(inum - 1 ) / s_inodes_per_group</code> 得到 Inode 所在的 Block Group</li>
<li><code>(inum - 1 ) % s_inodes_per_group</code> 可得到 Inode 在 inode Table 中的偏移量</li>
<li>通过 Block Group 的 Group Descriptors 找到 inode Table，根据偏移获取实际的 Inode 数据</li>
<li>通过 Inode 结构中的 <a target="_blank" rel="noopener" href="https://docs.huihoo.com/doxygen/linux/kernel/3.7/structext4__inode.html#a507f79fb9f060b109d465a6e8a32a6b1">i_block</a> 获取 Data Blocks 中对应的数据块</li>
<li>根据数据块中的结构读取实际数据：ext2 和 ext3 中结构为直接&#x2F;间接数据块表；ext4 中的结构则是 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/filesystems/ext4/dynamic.html#extent-tree">Extent Tree</a>；</li>
</ul>
</li>
</ul>
<h2 id="cp-x2F-rm-x2F-mv-x2F-tar-命令"><a href="#cp-x2F-rm-x2F-mv-x2F-tar-命令" class="headerlink" title="cp&#x2F;rm&#x2F;mv&#x2F;tar 命令"></a>cp&#x2F;rm&#x2F;mv&#x2F;tar 命令</h2><p>用 <code>strace</code> 可以很清楚地看到命令执行时的系统调用。一般 <code>rm</code> 主要用到 <code>unlink*</code>，<code>mv</code> 主要用到 <code>rename*</code>，<code>cp</code> 主要用到 <code>open</code>、<code>read</code>、<code>write</code>。</p>
<p>根据 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/unlink.2.html">linux&#x2F;man-pages&#x2F;unlink</a>，<code>unlink</code> 用于按照文件名删除文件：</p>
<ul>
<li>如果文件无其他链接，且没有进程打开该文件，则删除文件并释放空间</li>
<li>如果文件仅此一份链接，但存在进程仍然打开该文件，<strong>删除后文件依然存在</strong>，直到引用它的最后一个文件描述符关闭，系统才会回收</li>
</ul>
<p>因此通过 <code>unlink</code> 删除正在被使用的文件是安全的。</p>
<p><code>rename</code> 面对的场景更加复杂，根据 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/rename.2.html">linux&#x2F;man-pages&#x2F;rename</a>，当目标已经存在时</p>
<ul>
<li>如果是非跨盘行为，会保证操作的<strong>原子性</strong></li>
<li>如果是跨盘行为，则报错 <code>Invalid cross-device link</code></li>
<li>跨盘 <code>mv</code> 命令会忽略报错，通过 unlink 删除目标，新建文件后复制内容，最后 unlink 删除源文件</li>
</ul>
<p>根据 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/open.2.html">linux&#x2F;man-pages&#x2F;open</a>，当目标已存在，<code>cp</code> 命令调用 open 的参数会包含 <code>O_TRUNC</code>（即 truncate 模式），<strong>复用目标的 Inode</strong>，清空内容，把源文件内容写入目标。当程序正在运行时，调用 <code>cp</code> 尝试覆盖其二进制文件，会报错 <code>Text file busy</code>（但 cp 覆盖正在被使用的共享库则不然），这缘于操作系统的保护机制，详见 <a href="#%E6%A1%88%E4%BE%8B%EF%BC%882%EF%BC%89">案例（2）</a>。如果使用 <code>cp -f</code> 进行覆盖则会忽略报错，并执行 unlink 后再复制，<strong>前后 Inode 已经发生改变</strong>，属于安全行为。</p>
<p>追踪 <code>tar</code> 命令的执行过程，可以看到当目标已存在时，是 unlink 删除后再新建并复制写入。因此通过 tar 命令覆盖正在被使用的文件也是安全的。</p>
<h1 id="Linux-动态库"><a href="#Linux-动态库" class="headerlink" title="Linux 动态库"></a>Linux 动态库</h1><p>强烈推荐 <a target="_blank" rel="noopener" href="https://book.douban.com/subject/3652388/">《程序员的自我修养——链接装载与库》</a> 这本书，细致全面地囊括了各项相关知识。</p>
<p>Linux 下的库有两种：<code>静态库</code> 和 <code>共享库（aka 动态库）</code>，静态通常用 <code>.a</code> 为后缀，动态库用 <code>.so</code> 为后缀。</p>
<p>Linux 下动态库、静态库、可执行文件的格式均 <code>ELF（Executable Linkable Format）</code>，可通过 <code>file</code> 命令查看其具体类型细节。使用 <code>ldd</code> 工具，查看 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_file">Object file（目标文件）</a> 依赖的动态库。</p>
<p>动态库的优势：</p>
<ul>
<li>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</li>
<li>动态库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，生成的可执行程序代码体积较小</li>
<li>编译链接代价小，对于长期稳定的模块库，无需反复拷贝数据</li>
<li>动态替换，可支持程序热更新</li>
</ul>
<p>动态库的劣势：</p>
<ul>
<li>访问全局数据｜静态数据成员、跨模块函数调用等行为需要额外的定位寻址开销，造成性能损耗</li>
<li>模块兼容性问题：DDL hell</li>
</ul>
<p>链接相关概念中，函数和变量统称为 <code>符号（Symbol）</code>，函数名或变量名就是符号名。每个目标文件都有一个 <code>符号表（Symbol Table）</code>，表中记录了目标文件用到的所有符号。</p>
<p>使用 <code>nm</code> 命令查看目标文件的符号信息，<a target="_blank" rel="noopener" href="https://linux.die.net/man/1/nm">nm(1) - Linux man page</a>，符号类型主要包括：</p>
<ul>
<li>T &#x2F; t：代码段中的函数</li>
<li>U：被调用但并没有定义的符号（表明需要其他库支持）</li>
<li>W &#x2F; w：”弱态” 符号，它们虽然被定义，但是可能被其他库中的同名符号覆盖（常见于模板、结构体、类等使用场景）</li>
<li>B &#x2F; b：bss 中的未初始化全局&#x2F;局部变量</li>
<li>D &#x2F; d：数据段中初始化的全局&#x2F;局部变量</li>
<li>…</li>
</ul>
<hr>
<p>目标文件将不同属性的信息分<code>段（Segment）</code> 存储，可用 <code>objdump</code> 或 <code>readelf</code> 工具导出相关信息：</p>
<ul>
<li><code>.dynsym</code> 未定义分配的符号表</li>
<li><code>.rel.dyn</code> 加载时需要重定位的变量</li>
<li><code>.rel.plt</code> 需要重定位的函数</li>
<li><code>.text</code> 源代码编译后的指令</li>
<li><code>.plt</code> 延迟绑定的外部函数调用的指令</li>
<li><code>.data</code> 已初始化的全局变量和局部静态变量</li>
<li><code>.bss</code> 未初始化的全局变量和局部静态变量</li>
<li><code>.symtab</code> 全量符号表</li>
<li><code>.got</code> 外部全局变量地址表</li>
<li><code>.got.plt</code> 外部函数地址表</li>
<li>…</li>
</ul>
<p>为了使程序模块中共享的指令部分在装载时不需要随装载地址变动而变动，可将指令中需要被修改的部分分离出来放到数据部分中，这样指令部分保持不变，<strong>数据部分可以在每个进程中有独立可修改的副本</strong>，这种方案就是 <code>地址无关代码（PIC，Position-independent Code）</code>。实现方式：</p>
<ul>
<li>ELF 在数据相关表段里建立指向这些变量的指针数组，也被称为 <code>全局偏移表（Global Offset Table，GOT）</code>，当代码需要访问这些跨模块数据时，可通过 GOT 中变量对应的项找到目标地址</li>
<li>GOT 本身位于数据相关表段，可以在模块装载时被修改，链接器在装载模块时会查找变量的实际地址并填充 GOT</li>
<li>模块的数据相关表段在每个进程都有独立的副本</li>
<li>通常 ELF 将 GOT 拆分成 2 个表段：<code>.got</code> 和 <code>.got.plt</code></li>
</ul>
<p>跨模块的函数调用也是同样原理，每次调用前需要定位到函数在当前进程中的内存虚拟地址。ELF 普遍采用延迟绑定的的做法，基本思想是当函数第一次被调用时才进行绑定（符号查找、重定位等），使用 <code>PLT（Procedure Linkage Table）</code> 的方法来实现，详见 <a href="#%E6%A1%88%E4%BE%8B%EF%BC%881%EF%BC%89">案例（1）</a>。</p>
<h2 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h2><h3 id="案例（1）"><a href="#案例（1）" class="headerlink" title="案例（1）"></a>案例（1）</h3><p><em><strong>当程序链接多个包含相同函数的库时，可能出现非预期的结果</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libtest.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">foo</span>();&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v2.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang++ -c v1.cpp -o v1.o &amp;&amp; ar -cr libv1.a v1.o</span><br><span class="line">clang++ -c v2.cpp -o v2.o &amp;&amp; ar -cr libv2.a v2.o</span><br><span class="line">clang++ -fPIC libtest.cpp -L. -lv1 -shared -o libtest.so</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,<span class="built_in">foo</span>(),<span class="built_in">test</span>());&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行结果为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -L./ -lv2 -ltest -rpath `<span class="built_in">pwd</span>` -o main &amp;&amp; ./main</span><br><span class="line">2,2</span><br></pre></td></tr></table></figure>

<p>在 libtest.so 内部存在已定义的函数 <code>foo()</code> 和 <code>test()</code>，但实际上 test() 调用的是 v2 库中的 foo() 而不是 libtest.so 自身的，与直觉相悖。</p>
<p>交换库链接顺序 或者只链接 libtest.so，最终调用的才是 libtest.so 中的 foo() 。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -L./  -ltest -lv2 -rpath `<span class="built_in">pwd</span>` -o main &amp;&amp; ./main</span><br><span class="line">1,1</span><br><span class="line">clang++ main.cpp -L./ -ltest -rpath `<span class="built_in">pwd</span>` -o main &amp;&amp; ./main</span><br><span class="line">1,1</span><br></pre></td></tr></table></figure>

<h4 id="分析（1）"><a href="#分析（1）" class="headerlink" title="分析（1）"></a>分析（1）</h4><p>libtest.so 中对外导出函数 <code>test()</code> 和 <code>foo()</code> ，test() 内调用了 foo()，所以需要对 foo() 进行装载时重定位。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nm -CD libtest.so</span><br><span class="line"></span><br><span class="line">                 w __cxa_finalize</span><br><span class="line">0000000000001698 T _fini</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">000000000000167c T _init</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">0000000000001670 T foo()</span><br><span class="line">0000000000001660 T <span class="built_in">test</span>()</span><br></pre></td></tr></table></figure>

<p><code>foo</code> 外部函数入口偏移地址为 0x3910，在 .rela.plt 段的下标为 2，<code>.got.plt</code> 起始地址为 0x38e8，<code>.got.plt</code> 前 3 项为：<code>.dymanic</code> 段地址、本模块 ID、符合解析和重定位相关函数地址。验证得 0x38e8 + 8 * (3 + 2) &#x3D; 0x3910。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">readelf -r libtest.so</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.dyn&#x27;</span> at offset 0x430 contains 7 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">0000000026f0  000000000008 R_X86_64_RELATIVE                    26f0</span><br><span class="line">0000000026f8  000000000008 R_X86_64_RELATIVE                    1610</span><br><span class="line">000000002700  000000000008 R_X86_64_RELATIVE                    1650</span><br><span class="line">0000000028c8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line">0000000028d0  000200000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0</span><br><span class="line">0000000028d8  000300000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0</span><br><span class="line">0000000028e0  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.plt&#x27;</span> at offset 0x4d8 contains 3 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000003900  000100000007 R_X86_64_JUMP_SLO 0000000000000000 __gmon_start__ + 0</span><br><span class="line">000000003908  000400000007 R_X86_64_JUMP_SLO 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0</span><br><span class="line">000000003910  000800000007 R_X86_64_JUMP_SLO 0000000000001670 _Z3foov + 0</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">readelf -S libtest.so</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  [13] .plt              PROGBITS         00000000000016b0  000006b0</span><br><span class="line">       0000000000000040  0000000000000000  AX       0     0     16</span><br><span class="line">  [18] .got              PROGBITS         00000000000028c8  000008c8</span><br><span class="line">       0000000000000020  0000000000000000  WA       0     0     8</span><br><span class="line">  [19] .data             PROGBITS         00000000000038e8  000008e8</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [21] .got.plt          PROGBITS         00000000000038e8  000008e8</span><br><span class="line">       0000000000000030  0000000000000000  WA       0     0     8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>魔改下 main.cpp 令其持续 sleep 不退出，运行时可以根据 pid 查看进程地址空间：</p>
<ul>
<li>00201000-00202000 段主要是源代码编译后的指令，可读可执行，不可写</li>
<li>00200000-00201000 ，00202000-00203000 段为只读数据部分，前者主要是字符串常量，后者则主要是静态数据</li>
<li>00203000-00204000 段为可写数据部分</li>
<li>libtest.so 对应的内存地址空间从 7f0fb3704000 开始，布局与上面类似</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/&lt;pid-of-program&gt;/maps</span><br><span class="line"></span><br><span class="line">00200000-00201000 r--p 00000000 103:00 122162998                         /.../main</span><br><span class="line">00201000-00202000 r-xp 00000000 103:00 122162998                         /.../main</span><br><span class="line">00202000-00203000 r--p 00000000 103:00 122162998                         /.../main</span><br><span class="line">00203000-00204000 rw-p 00000000 103:00 122162998                         /.../main</span><br><span class="line">...</span><br><span class="line">7f0fb3704000-7f0fb3705000 r--p 00000000 103:00 122163012                 /.../libtest.so</span><br><span class="line">7f0fb3705000-7f0fb3706000 r-xp 00000000 103:00 122163012                 /.../libtest.so</span><br><span class="line">7f0fb3706000-7f0fb3707000 r--p 00000000 103:00 122163012                 /.../libtest.so</span><br><span class="line">7f0fb3707000-7f0fb3708000 rw-p 00000000 103:00 122163012                 /.../libtest.so</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>该案例使用动态库的方式为<code>隐式加载（载入时加载）</code></p>
<ul>
<li>类似静态库链接的过程发生在程序加载时，动态链接器将所有相关动态库装载到进程地址空间，将程序中未定义的符号绑定到相应的动态链接库，进行重定位工作，即 <code>装载时重定位（Load Time Relocation）</code>：<ul>
<li>链接器按照深度｜广度优先顺序加载把程序和相关共享库的符号表都合并到 <strong>全局符号表（Global Symbol Table）</strong></li>
<li>链接器基本规则：全局符号表中已存在同名符号，则后加入的忽略</li>
</ul>
</li>
<li>首先载入主程序，main 中默认导出 foo() 且对应 v2 库的实现，foo 函数符号和地址 0x201800 先注册到全局符号表。</li>
<li>2017c0: 压栈 <code>rbp（栈基地址寄存器）</code> 的值，保存调用者帧的栈底</li>
<li>2017c1: 将 <code>rsp（栈指针寄存器，指向栈顶）</code> 的值赋予 rbp，将调用者帧的栈顶设为当前帧的栈底，等于开辟新栈</li>
<li>2017c4: 预留 16字节空间给临时数据</li>
<li>2017c8: 调用 foo() 函数，callq 约等于 push %rip + jump &lt;_Z3foov&gt;</li>
<li>201804: 设置返回值至 eax 寄存器</li>
<li>2017cd ～ 2017eb: 调用 print() 和 test() 函数</li>
<li>2017ed: 清除预留空间，还原 rsp</li>
<li>2017f1: 还原 rbp</li>
<li>2017f2: 跳转回调用者的指令，约等于 pop %rip + jump …</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">objdump -d main</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">00000000002017c0 &lt;main&gt;:</span><br><span class="line">  2017c0:       55                      push   %rbp</span><br><span class="line">  2017c1:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  2017c4:       48 83 ec 10             sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">  2017c8:       e8 33 00 00 00          callq  201800 &lt;_Z3foov&gt;</span><br><span class="line">  2017cd:       89 45 <span class="built_in">fc</span>                mov    %eax,-0x4(%rbp)</span><br><span class="line">  2017d0:       e8 0b 01 00 00          callq  2018e0 &lt;_Z4testv@plt&gt;</span><br><span class="line">  2017d5:       8b 75 <span class="built_in">fc</span>                mov    -0x4(%rbp),%esi</span><br><span class="line">  2017d8:       89 c2                   mov    %eax,%edx</span><br><span class="line">  2017da:       48 bf b0 05 20 00 00    movabs <span class="variable">$0x2005b0</span>,%rdi</span><br><span class="line">  2017e1:       00 00 00</span><br><span class="line">  2017e4:       b0 00                   mov    <span class="variable">$0x0</span>,%al</span><br><span class="line">  2017e6:       e8 05 01 00 00          callq  2018f0 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">  2017eb:       31 c0                   xor    %eax,%eax</span><br><span class="line">  2017ed:       48 83 c4 10             add    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">  2017f1:       5d                      pop    %rbp</span><br><span class="line">  2017f2:       c3                      retq</span><br><span class="line">...  </span><br><span class="line">0000000000201800 &lt;_Z3foov&gt;:</span><br><span class="line">  201800:       55                      push   %rbp</span><br><span class="line">  201801:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  201804:       b8 02 00 00 00          mov    <span class="variable">$0x2</span>,%eax</span><br><span class="line">  201809:       5d                      pop    %rbp</span><br><span class="line">  20180a:       c3                      retq</span><br><span class="line">...  </span><br><span class="line">00000000002018e0 &lt;_Z4testv@plt&gt;:</span><br><span class="line">  2018e0:       ff 25 42 22 00 00       jmpq   *0x2242(%rip)        <span class="comment"># 203b28 &lt;_Z4testv@Base&gt;</span></span><br><span class="line">  2018e6:       68 02 00 00 00          pushq  <span class="variable">$0x2</span></span><br><span class="line">  2018eb:       e9 c0 ff ff ff          jmpq   2018b0 &lt;_fini+0x10&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 libtest.so 对外导出 foo()，所以 test 函数调用 foo 无法按照模块内函数调用的方式，编译器会当作 <strong>模块外函数</strong> 处理。<ul>
<li>设 α 为 libtest.so 载入程序的起始内存地址</li>
<li>1664: 通过命令可以看到 <code>&lt;_Z4testv&gt;</code> 实际调用的是 <code>&lt;_Z3foov@plt&gt;</code> 而非 <code>&lt;_Z3foov&gt;</code><ul>
<li>指令码为 e8 77 00 00 00，第一字节表示指令类型为 <strong>相对地址调用（Call near, relative, displacement relative to next instruction）</strong>，后四子节是目标地址相对于当前指令下一条指令的偏移 0x77，即 0x1669 + 0x77 &#x3D; 0x16e0，最后调用的是 α + 0x16e0</li>
</ul>
</li>
<li>16e0: 通过偏移地址 0x3910 间接跳转<ul>
<li>读取指令寄存器 rip 中的值 β（α + 0x16e6）；加上偏移 γ &#x3D; β + 0x222a &#x3D; α + 0x3910（该地址位于 <code>.got.plt</code> 段，用于保存外部函数 foo() 对应的项）；从地址 γ 读取地址 δ；跳转到地址 δ；</li>
<li>如果链接器已经初始化 γ，δ 为外部函数 foo() 的进程内地址，则可直接跳转实现函数调用</li>
<li>为了实现延迟绑定，初始化时填入 γ 实际上是 “16e6:” 行对应的地址 α + 0x16e6，等效于是间接跳转到下一行</li>
</ul>
</li>
<li>16e6: 压栈外部函数 foo() 在 <code>.rela.plt</code> 段中的下标 2</li>
<li>16eb: 跳转到符号解析和重定位流程入口，从全局符号表中获取 foo() 的进程内地址 0x201800 填入地址 γ，最后调用 foo() 函数</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objdump -d libtest.so</span><br><span class="line"></span><br><span class="line">0000000000001660 &lt;_Z4testv&gt;:</span><br><span class="line">    1660:       55                      push   %rbp</span><br><span class="line">    1661:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1664:       e8 77 00 00 00          callq  16e0 &lt;_Z3foov@plt&gt;</span><br><span class="line">    1669:       5d                      pop    %rbp</span><br><span class="line">    166a:       c3                      retq</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0000000000001670 &lt;_Z3foov&gt;:</span><br><span class="line">    1670:       55                      push   %rbp</span><br><span class="line">    1671:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1674:       b8 01 00 00 00          mov    <span class="variable">$0x1</span>,%eax</span><br><span class="line">    1679:       5d                      pop    %rbp</span><br><span class="line">    167a:       c3                      retq</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">00000000000016e0 &lt;_Z3foov@plt&gt;:</span><br><span class="line">    16e0:       ff 25 2a 22 00 00       jmpq   *0x222a(%rip)        <span class="comment"># 3910 &lt;_Z3foov@@Base+0x22a0&gt;</span></span><br><span class="line">    16e6:       68 02 00 00 00          pushq  <span class="variable">$0x2</span></span><br><span class="line">    16eb:       e9 c0 ff ff ff          jmpq   16b0 &lt;_fini+0x18&gt;        </span><br><span class="line">...    </span><br></pre></td></tr></table></figure>

<ul>
<li>载入 libtest.so 符号表时，foo 函数符号无法注册到全局符号表</li>
<li>libtest.so 中 PLT 重定位时填入全局符号表中 foo 函数符号对应的地址，最终调用 v2 库的逻辑</li>
</ul>
<hr>
<p>交换库链接顺序或者只链接 libtest.so 时也是同样原理，main 程序中 foo 函数符号被编译器决议成为未定义（U类），加载 libtest.so 时注册到全局符号表。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nm -CD main</span><br><span class="line"></span><br><span class="line">0000000000201880 T _fini</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">0000000000201864 T _init</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">                 U __libc_start_main</span><br><span class="line">                 U <span class="built_in">printf</span></span><br><span class="line">                 U foo()</span><br><span class="line">                 U <span class="built_in">test</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">00000000002017b0 &lt;main&gt;:</span><br><span class="line">...</span><br><span class="line">  2017b8:       e8 03 01 00 00          callq  2018c0 &lt;_Z3foov@plt&gt;</span><br><span class="line">...</span><br><span class="line">  2017c0:       e8 0b 01 00 00          callq  2018d0 &lt;_Z4testv@plt&gt;</span><br><span class="line">...  </span><br></pre></td></tr></table></figure>

<h3 id="解决符号冲突"><a href="#解决符号冲突" class="headerlink" title="解决符号冲突"></a>解决符号冲突</h3><p>为避免符号冲突，可通过以下几种方式</p>
<h4 id="显式加载（运行时加载）"><a href="#显式加载（运行时加载）" class="headerlink" title="显式加载（运行时加载）"></a>显式加载（运行时加载）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> *handle = <span class="built_in">dlopen</span>(<span class="string">&quot;./libtest.so&quot;</span>,RTLD_LAZY); <span class="built_in">assert</span>(handle);</span><br><span class="line">    <span class="built_in">int</span> (*test)() = (<span class="built_in">int</span> (*)())<span class="built_in">dlsym</span>(handle,<span class="string">&quot;_Z4testv&quot;</span>); <span class="built_in">assert</span>(test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="built_in">foo</span>(), <span class="built_in">test</span>());</span><br><span class="line">    <span class="built_in">dlclose</span>(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行时，在逻辑中加载 libtest.so 获取 test 函数入口。编译时则不需要链接项 -ltest。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang++ main2.cpp -L./ -lv2 -ldl -rpath `<span class="built_in">pwd</span>` -o main2 &amp;&amp; ./main2</span><br><span class="line">2,1</span><br><span class="line">clang++ main2.cpp -L./ -lv1 -ldl -rpath `<span class="built_in">pwd</span>` -o main2 &amp;&amp; ./main2</span><br><span class="line">1,1</span><br></pre></td></tr></table></figure>

<hr>
<p>当进程中的模块是通过 <code>dlopen()</code> 载入的共享对象，<code>dlsym()</code> 查找符号的优先级分为 2 种：</p>
<ul>
<li>dlopen() 参数 <code>filename</code> 为 nullptr， 则是从全局符号表查找，即 <code>装载序列（Load Ordering）</code>。</li>
<li>dlopen() 指定共享对象时，则采用 <code>依赖序列（Dependency Ordering）</code> 的优先级：以被 dlopen() 打开的共享对象为节点，对其依赖对象进行广度优先遍历，直到找到符号。</li>
</ul>
<h4 id="符号隐藏"><a href="#符号隐藏" class="headerlink" title="符号隐藏"></a>符号隐藏</h4><ul>
<li>隐藏 main 入口 foo() 函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">__attribute__ ((<span class="built_in">visibility</span> (<span class="string">&quot;hidden&quot;</span>))) <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;std::cout&lt;&lt;<span class="built_in">foo</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="built_in">test</span>()&lt;&lt;std::endl;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ main3.cpp -L./ -lv2 -ltest -rpath `<span class="built_in">pwd</span>` -o main3 &amp;&amp; ./main3</span><br><span class="line">2,1</span><br></pre></td></tr></table></figure>

<ul>
<li>隐藏共享库内 foo() 函数，<strong>推荐这种方式，尽可能对外隐藏无关符号</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libtest2.cpp</span></span><br><span class="line">__attribute__ ((<span class="built_in">visibility</span> (<span class="string">&quot;hidden&quot;</span>))) <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">foo</span>();&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang++ -fPIC libtest2.cpp -L. -lv1 -shared -o libtest2.so</span><br><span class="line">clang++ main.cpp -L./ -lv2 -ltest2 -rpath `<span class="built_in">pwd</span>` -o main &amp;&amp; ./main</span><br><span class="line">2,1</span><br></pre></td></tr></table></figure>

<p>foo() 对外不可见；此时 test() 调用 foo() 为模块内调用，无需通过 PLT；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objdump -d libtest.so</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">0000000000001620 &lt;_Z4testv&gt;:</span><br><span class="line">    1620:       55                      push   %rbp</span><br><span class="line">    1621:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1624:       e8 07 00 00 00          callq  1630 &lt;_Z3foov&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="替换动态库"><a href="#替换动态库" class="headerlink" title="替换动态库"></a>替换动态库</h2><h3 id="案例（2）"><a href="#案例（2）" class="headerlink" title="案例（2）"></a>案例（2）</h3><p>如果 so 正在被使用时，执行 <code>cp $&#123;newlib&#125;.so $&#123;oldlib&#125;.so</code>，则容易引起程序 core dump。</p>
<h4 id="分析（2）"><a href="#分析（2）" class="headerlink" title="分析（2）"></a>分析（2）</h4><ul>
<li>应用程序加载动态库时，内核通过 mmap 把 so 加载到进程地址空间，对应 <code>Virtual memory area (VMA)</code> 中多个 <code>页（Page）</code><ul>
<li>相同 Inode 的 so 可被不同程序共享页缓存</li>
<li>段的装载地址和空间的对齐单位是页</li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man8/ld.so.8.html">dynamic linker&#x2F;loader</a> 会把 so 里面引用的外部符号按照上文所述步骤进行解析和重定位</li>
</ul>
</li>
<li>当 so 被 <code>cp</code> 以 truncate 模式覆盖时，内核会把 so 文件在虚拟内存页清除掉</li>
<li>运行到 so 里面的代码时，因为虚拟内存页已被清除，会产生一次缺页中断</li>
<li>缺页中断会导致内核从 so 文件中拷贝对应的页到内存中，<strong>so 地址范围内的数据相关表段也会替换为原始值，GOT &#x2F; PLT 相关因此丢失重定位信息</strong></li>
<li>前后 so 不一样，则逻辑执行结果不可知<ul>
<li>例如需要的访问的地址偏移大于新的 so 的地址范围，就会产生 <code>Bus error</code></li>
<li>访问非法地址则会引起 <code>Segmentation fault</code></li>
</ul>
</li>
<li>前后 so 文件完全一致：<ul>
<li>如果调用到依赖外部符号的逻辑，但此时外部符号并没有经过重新解析，直接使用 <code>.got</code> &#x2F; <code>.got.plt</code> 段数据，则会引起访问非法地址 <code>Segmentation fault</code></li>
<li>如果调用的逻辑没有依赖外部符号<ul>
<li>如果逻辑依赖 <code>.data</code> &#x2F; <code>.bss</code> 段数据（例如静态变量），则会因为数据被替换而引发逻辑异常</li>
<li>如果逻辑没有其他依赖，则可正常运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>为什么系统会阻止 <code>cp</code> 覆盖可执行程序，而不阻止覆盖 so 文件？</p>
<ul>
<li>操作系统的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Demand_paging">Demand Paging</a> 机制下，加载程序时也同上文一样映射 VMA，有访存需求时才加载相关页。</li>
<li>为防止正在运行中的程序镜像（并非文件本身）被意外修改，因此内核在启动程序后会锁定这个程序镜像的 Inode。</li>
<li>so 文件是靠 ld.so 加载的，属于用户态程序，没有权限锁定 Inode。</li>
</ul>
<hr>
<p><strong>结合上述内容，替换动态库时，必须先执行系统调用 <code>unlink*</code> 删除目标。因此禁止直接使用 <code>cp</code>，可选 <code>install</code>、<code>rm + cp</code> 等</strong></p>
<h2 id="动态库性能开销"><a href="#动态库性能开销" class="headerlink" title="动态库性能开销"></a>动态库性能开销</h2><p><a href="#%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89">分析（1）</a> 中已基本描述了加载动态库和调用动态库内函数的流程。除此之外，动态库使用外部变量和全局变量时也有额外的寻址开销。</p>
<h3 id="案例（3）"><a href="#案例（3）" class="headerlink" title="案例（3）"></a>案例（3）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libtest3.cpp</span></span><br><span class="line"><span class="type">int</span> k=<span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">koo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> k++;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">goo</span><span class="params">()</span></span>&#123;<span class="type">static</span> <span class="type">int</span> g=<span class="number">234</span>;<span class="keyword">return</span> g++;&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> p++;&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> f=<span class="number">666</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> f++;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -fPIC libtest3.cpp -shared -o libtest3.so</span><br></pre></td></tr></table></figure>

<p>全局变量 <code>k</code> 和外部变量 <code>p</code> 的访问方式相同，需要读 GOT，例如 koo() 中的步骤为：</p>
<ul>
<li>1764: 读取 <code>rip</code> 寄存器中下个指令的实际内存地址，加上 <code>k</code> 在 GOT 中对应项的偏移地址 0x12bd，读取 <code>k</code> 的内存地址并保存至 <code>rax</code> 寄存器</li>
<li>176b: 根据 <code>rax</code> 寄存器中的值再次寻址读取保存至 <code>eax</code> 寄存器</li>
</ul>
<p>静态局部变量 <code>goo()::g</code> 和静态全局变量 <code>foo()::f</code> 的访问则无需 GOT：</p>
<ul>
<li>1784: 通过 <code>rip</code> 寄存器和偏移地址 0x22b2 直接获取 <code>goo()::g</code> 在当前进程内存空间中的值至 <code>eax</code> 寄存器</li>
<li>动态库内访问静态变量，与使用静态链接库时是一样的 8b 类型的 mov 指令，性能上差距微乎其微</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">nm -CD libtest3.so</span><br><span class="line"></span><br><span class="line">                 w __cxa_finalize</span><br><span class="line">00000000000017f4 T _fini</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">00000000000017d8 T _init</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">0000000000003a38 D k</span><br><span class="line">                 U p</span><br><span class="line">00000000000017c0 T foo()</span><br><span class="line">0000000000001780 T goo()</span><br><span class="line">0000000000001760 T koo()</span><br><span class="line">00000000000017a0 T poo()</span><br><span class="line"></span><br><span class="line">objdump -d libtest3.so</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">0000000000001760 &lt;_Z3koov&gt;:</span><br><span class="line">    1760:       55                      push   %rbp</span><br><span class="line">    1761:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1764:       48 8b 05 bd 12 00 00    mov    0x12bd(%rip),%rax        <span class="comment"># 2a28 &lt;k@@Base-0x1010&gt;</span></span><br><span class="line">    176b:       8b 00                   mov    (%rax),%eax</span><br><span class="line">    176d:       89 c2                   mov    %eax,%edx</span><br><span class="line">    176f:       83 c2 01                add    <span class="variable">$0x1</span>,%edx</span><br><span class="line">    1772:       48 8b 0d af 12 00 00    mov    0x12af(%rip),%rcx        <span class="comment"># 2a28 &lt;k@@Base-0x1010&gt;</span></span><br><span class="line">    1779:       89 11                   mov    %edx,(%rcx)</span><br><span class="line">    177b:       5d                      pop    %rbp</span><br><span class="line">    177c:       c3                      retq</span><br><span class="line">    177d:       0f 1f 00                nopl   (%rax)</span><br><span class="line"></span><br><span class="line">0000000000001780 &lt;_Z3goov&gt;:</span><br><span class="line">    1780:       55                      push   %rbp</span><br><span class="line">    1781:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1784:       8b 05 b2 22 00 00       mov    0x22b2(%rip),%eax        <span class="comment"># 3a3c &lt;_ZZ3goovE1g&gt;</span></span><br><span class="line">    178a:       89 c1                   mov    %eax,%ecx</span><br><span class="line">    178c:       83 c1 01                add    <span class="variable">$0x1</span>,%ecx</span><br><span class="line">    178f:       89 0d a7 22 00 00       mov    %ecx,0x22a7(%rip)        <span class="comment"># 3a3c &lt;_ZZ3goovE1g&gt;</span></span><br><span class="line">    1795:       5d                      pop    %rbp</span><br><span class="line">    1796:       c3                      retq</span><br><span class="line">    1797:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)</span><br><span class="line">    179e:       00 00</span><br><span class="line"></span><br><span class="line">00000000000017a0 &lt;_Z3poov&gt;:</span><br><span class="line">    17a0:       55                      push   %rbp</span><br><span class="line">    17a1:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    17a4:       48 8b 05 85 12 00 00    mov    0x1285(%rip),%rax        <span class="comment"># 2a30 &lt;p@Base&gt;</span></span><br><span class="line">    17ab:       8b 00                   mov    (%rax),%eax</span><br><span class="line">    17ad:       89 c2                   mov    %eax,%edx</span><br><span class="line">    17af:       83 c2 01                add    <span class="variable">$0x1</span>,%edx</span><br><span class="line">    17b2:       48 8b 0d 77 12 00 00    mov    0x1277(%rip),%rcx        <span class="comment"># 2a30 &lt;p@Base&gt;</span></span><br><span class="line">    17b9:       89 11                   mov    %edx,(%rcx)</span><br><span class="line">    17bb:       5d                      pop    %rbp</span><br><span class="line">    17bc:       c3                      retq</span><br><span class="line">    17bd:       0f 1f 00                nopl   (%rax)</span><br><span class="line"></span><br><span class="line">00000000000017c0 &lt;_Z3foov&gt;:</span><br><span class="line">    17c0:       55                      push   %rbp</span><br><span class="line">    17c1:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    17c4:       8b 05 76 22 00 00       mov    0x2276(%rip),%eax        <span class="comment"># 3a40 &lt;_ZL1f&gt;</span></span><br><span class="line">    17ca:       89 c1                   mov    %eax,%ecx</span><br><span class="line">    17cc:       83 c1 01                add    <span class="variable">$0x1</span>,%ecx</span><br><span class="line">    17cf:       89 0d 6b 22 00 00       mov    %ecx,0x226b(%rip)        <span class="comment"># 3a40 &lt;_ZL1f&gt;</span></span><br><span class="line">    17d5:       5d                      pop    %rbp</span><br><span class="line">    17d6:       c3                      retq</span><br><span class="line">...    </span><br></pre></td></tr></table></figure>

<hr>
<p>通常来说动态库会尽量少使用外部变量和全局变量，以获得更好的隔离性，减少符号依赖风险，所以一般情况下讨论动态库的性能损耗着重于跨模块函数调用（额外的内存间接寻址，跨模块访存局部性变差）。但绝大多数实际应用层面，这些开销基本可以忽略。</p>
<h2 id="共享库兼容性"><a href="#共享库兼容性" class="headerlink" title="共享库兼容性"></a>共享库兼容性</h2><p><a href="#%E6%A1%88%E4%BE%8B%EF%BC%881%EF%BC%89">案例（1）</a>，<a href="#%E6%A1%88%E4%BE%8B%EF%BC%882%EF%BC%89">案例（2）</a>，<a href="#%E6%A1%88%E4%BE%8B%EF%BC%883%EF%BC%89">案例（3）</a> 中使用的均是 C++ 的 <code>ABI (Application binary interface)</code>，由于其标准会随着编译器而改变，所以假如程序直接使用第三方的二进制库，务必保证双方的 ABI 标准一致。C 语言的 ABI 则相对稳定，加之大部分操作系统为其标准背书。实际生产环境应用中，跨语言 &#x2F; 跨模块 交互的场景基本用的都是 C 式接口。</p>
<p>共享库动态链接｜装载时搜索路径顺序：</p>
<ol>
<li>编译目标代码时指定的共享库搜索路径（设置 rpath）</li>
<li>环境变量 <code>LD_LIBRARY_PATH</code> 指定共享库搜索路径</li>
<li>配置文件 <code>/etc/ld.so.conf</code> 中指定的共享库搜索路径</li>
<li>默认的共享库搜索路径：<code>/lib</code>、<code>/usr/lib</code>、<code>/usr/local/lib</code></li>
</ol>
<p>Linux 有一套共享库命名规范 <em><strong>libname.so.x.y.z</strong></em></p>
<ul>
<li>前缀 <code>lib</code>，库名称，后缀 <code>.so</code>，3 个版本号</li>
<li><code>x</code> 表示主版本号（Major），<code>y</code> 表示次版本号（Minor），<code>z</code> 表示发布版本号（Release）<ul>
<li>主版本号不同的库不保证兼容</li>
<li>次版本号表示库增量升级，只新增符号</li>
<li>发布版本号表示内部修改，不改变符号</li>
</ul>
</li>
</ul>
<h3 id="案例（4）"><a href="#案例（4）" class="headerlink" title="案例（4）"></a>案例（4）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main4.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;version %d\n&quot;</span>, <span class="built_in">foo</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libtest4.1.1.1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">10101</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>指定共享库的 <code>SO-NAME</code> 为 libtest4.so.1（仅保留主版本号），该软链接保持指向目录中相同主版本，次版本和发布版本最新的共享库。当进行共享库兼容式升级时，只需修改该软链接。程序打包发布时，则需打包该软链接以及实际指向的共享库文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clang++ -fPIC libtest4.1.1.1.cpp -shared -Wl,-soname,libtest4.so.1 -o libtest4.so.1.1.1</span><br><span class="line"><span class="built_in">ln</span> -sf libtest4.so.1.1.1 libtest4.so.1</span><br><span class="line"><span class="built_in">ln</span> -sf libtest4.so.1 libtest4.so</span><br><span class="line"></span><br><span class="line">readelf -d libtest4.so.1.1.1 | grep <span class="string">&#x27;SONAME&#x27;</span></span><br><span class="line"> 0x000000000000000e (SONAME)             Library soname: [libtest4.so.1]</span><br><span class="line"> </span><br><span class="line">clang++ main4.cpp -L`<span class="built_in">pwd</span>` -rpath `<span class="built_in">pwd</span>` -ltest4 -o main4 &amp;&amp; ./main4</span><br><span class="line">version 10101</span><br><span class="line"></span><br><span class="line">ldd main4 | grep test4</span><br><span class="line">        libtest4.so.1 (0x00007f59c9009000)</span><br></pre></td></tr></table></figure>

<h3 id="案例（5）"><a href="#案例（5）" class="headerlink" title="案例（5）"></a>案例（5）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libtest5.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1234</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libtest5.2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">8888</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libtest5_expect.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">go</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1234</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libtest5_expect.2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">go</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">8888</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main5.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">load_run</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * lib_name, <span class="type">const</span> <span class="type">char</span> * func_name, <span class="type">int</span> * res)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span> * handle = <span class="built_in">dlopen</span>(lib_name, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        <span class="built_in">int</span> (*foo)() = (<span class="built_in">int</span> (*)())<span class="built_in">dlsym</span>(handle, func_name);</span><br><span class="line">        <span class="built_in">assert</span>(foo);</span><br><span class="line">        *res = <span class="built_in">foo</span>();</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">dlclose</span>(handle);</span><br><span class="line">        <span class="built_in">assert</span>(!r);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> expect_val = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">load_run</span>(<span class="string">&quot;./libtest5.so&quot;</span>, <span class="string">&quot;foo&quot;</span>, &amp;res));</span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">load_run</span>(<span class="string">&quot;./libtest5_expect.so&quot;</span>, <span class="string">&quot;go&quot;</span>, &amp;expect_val));</span><br><span class="line">        <span class="keyword">if</span>(res != expect_val) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;invalid result, expect %d got %d\n&quot;</span>, expect_val, res);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;result equal %d\n&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang++ -fPIC libtest5.2.cpp -shared -o libtest5.2.so</span><br><span class="line">clang++ -fPIC libtest5.cpp -shared -o libtest5.so</span><br><span class="line">clang++ -fPIC libtest5_expect.cpp -shared -o libtest5_expect.so</span><br><span class="line">clang++ -fPIC libtest5_expect.2.cpp -shared -o libtest5_expect.2.so</span><br><span class="line">clang++ -L`<span class="built_in">pwd</span>` -o main5 -ldl main5.cpp</span><br></pre></td></tr></table></figure>

<p>在 main5 运行过程中执行 <code>mv libtest5.2.so libtest5.so</code> 等 10s 后执行 <code>mv libtest5_expect.2.so libtest5_expect.so</code>，可见看出这段时间内出现了非预期的逻辑报错。</p>
<p>假如程序存在运行时装载使用共享库的行为，为了保障服务的稳定，需要尽可能令更新二进制文件的操作满足原子性，否则就得在程序逻辑侧加以控制。</p>
<h3 id="案例（6）"><a href="#案例（6）" class="headerlink" title="案例（6）"></a>案例（6）</h3><p>在 <code>x86_64</code> 平台下，把基于 CentOS7 编译的 TiFlash 二进制文件放到较新的 <code>Ubuntu:21.10</code> 系统中可以正常运行，但在 <code>aarch64</code> 平台下则会出现以下报错</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tiflash: /lib/aarch64-linux-gnu/libpthread.so.0: version `GLIBC_PRIVATE<span class="string">&#x27; not found (required by ./tiflash)</span></span><br></pre></td></tr></table></figure>

<h4 id="分析（6）"><a href="#分析（6）" class="headerlink" title="分析（6）"></a>分析（6）</h4><p><strong>TiFlash 的模块构成是什么样的？</strong></p>
<p>以当前较新的 commit 为例 <a target="_blank" rel="noopener" href="https://github.com/pingcap/tiflash/commit/636fcd22371266ee2792b4e0636cf96b4cacaa0c">636fcd22371266ee2792b4e0636cf96b4cacaa0c</a>，v6.0 之后整体工具链从 GCC-7.x 切换为 LLVM-13，CentOS7 系统编译出的二进制对应的动态库依赖如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ldd ./tiflash</span><br><span class="line"></span><br><span class="line">        linux-vdso.so.1 (0x00007ffc575f5000)</span><br><span class="line">        libc++.so.1 =&gt; /root/test/tiflash/./libc++.so.1 (0x00007f109618c000)</span><br><span class="line">        libc++abi.so.1 =&gt; /root/test/tiflash/./libc++abi.so.1 (0x00007f1096148000)</span><br><span class="line">        libtiflash_proxy.so =&gt; /root/test/tiflash/./libtiflash_proxy.so (0x00007f1093343000)</span><br><span class="line">        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f109333c000)</span><br><span class="line">        librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f1093337000)</span><br><span class="line">        libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f1093253000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f109324c000)</span><br><span class="line">        libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f1093232000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f109300a000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f109625d000)</span><br></pre></td></tr></table></figure>

<p><code>libtiflash_proxy.so</code> 是一个 Rust 语言编写的动态库：<a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb-engine-ext">tidb-engine-ext</a>，通过工具查看其导出的符号为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000aadda0 T bz_internal_error</span><br><span class="line">0000000000ee9e30 T perf_signal_handler</span><br><span class="line">00000000010b5200 T print_raftstore_proxy_version</span><br><span class="line">00000000010b5210 T run_raftstore_proxy_ffi</span><br><span class="line">0000000000e96c00 T rust_eh_personality</span><br></pre></td></tr></table></figure>

<p>Glibc 库中可以看到类似于 <code>GCC_</code> 为前缀或者是 <code>GLIBC_PRIVATE</code> 的符号版本。后者表示 <strong>非公开版本</strong>，有可能随着共享库的版本演化而被删除或改变，最好不要使用这些符号，否则风险自负。</p>
<p>查看 TiFlash 的符号表可知共有 3 个地方用到 <code>GLIBC_PRIVATE</code>。而 Ubuntu:21.10 中 的 <code>/lib/aarch64-linux-gnu/libpthread.so.0</code> 和 <code>/lib/aarch64-linux-gnu/libc.so.6</code> 已然没有对应的符号。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">readelf -a --wide ./tiflash | grep <span class="string">&#x27;GLIBC_PRIVATE&#x27;</span></span><br><span class="line"></span><br><span class="line">00000726a048  026c00000406 R_AARCH64_TLS_TPR 0000000000000000 errno@GLIBC_PRIVATE + 0</span><br><span class="line">0000072827b8  026b00000402 R_AARCH64_JUMP_SL 0000000000000000 __pthread_get_minstack@GLIBC_PRIVATE + 0</span><br><span class="line">0000072827c0  026d00000402 R_AARCH64_JUMP_SL 0000000000000000 __gai_sigqueue@GLIBC_PRIVATE + 0</span><br><span class="line">   619: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __pthread_get_minstack@GLIBC_PRIVATE (9)</span><br><span class="line">   620: 0000000000000000     0 TLS     GLOBAL DEFAULT  UND errno@GLIBC_PRIVATE (10)</span><br><span class="line">   621: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __gai_sigqueue@GLIBC_PRIVATE (10)</span><br><span class="line">  268:   2 (GLIBC_2.17)    4 (GLIBC_2.17)    4 (GLIBC_2.17)    9 (GLIBC_PRIVATE)</span><br><span class="line">  26c:   a (GLIBC_PRIVATE)   a (GLIBC_PRIVATE)   2 (GLIBC_2.17)    4 (GLIBC_2.17) </span><br><span class="line">  0x0080:   Name: GLIBC_PRIVATE  Flags: none  Version: 9</span><br><span class="line">  0x00d0:   Name: GLIBC_PRIVATE  Flags: none  Version: 10</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>符号是如何被引入的？</strong></p>
<p>以 <code>__gai_sigqueue</code> 为例，进到 编译目录｜源码目录 下，对所有文件（包括二进制）检索关键字 <code>__gai_sigqueue</code>，结果显示只有编译终产物 tiflash 二进制文件包含该信息，可以看出符号不是本地代码引入的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;build_dir&#125;</span></span><br><span class="line">grep <span class="string">&#x27;__gai_sigqueue&#x27;</span> -r .</span><br><span class="line"></span><br><span class="line">Binary file dbms/src/Server/tiflash matches</span><br></pre></td></tr></table></figure>

<p>查看 TiFlash 编译流程最后的链接命令，参数中包含 2 个外部静态库 <code>/usr/lib64/librt.a</code> 和 <code>/usr/lib64/libanl.a</code>。</p>
<p>分别导出 <code>重定位表</code> 可知是 <code>/usr/lib64/libanl.a</code> 的 <code>gai_notify.o</code> 引用了 <code>__gai_sigqueue</code>，对应 2 个 <code>重定位入口（Relocation Entry）</code>：OFFSET 0000000000000081，OFFSET 00000000000001c2。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">objdump -r /usr/lib64/libanl.a</span><br><span class="line"></span><br><span class="line">gai_notify.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">...</span><br><span class="line">0000000000000081 R_X86_64_PC32     __gai_sigqueue-0x0000000000000004</span><br><span class="line">...</span><br><span class="line">00000000000001c2 R_X86_64_PC32     __gai_sigqueue-0x0000000000000004</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">objdump -r /usr/lib64/librt.a | grep <span class="string">&#x27;__gai_sigqueue&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反汇编 <code>/usr/lib64/libanl.a</code> 找到 <code>gai_notify.o</code> 的 81 位置附近信息，可知是 <code>__gai_notify_only()</code> 和 <code>__gai_notify()</code> 函数调用了 <code>__gai_sigqueue()</code> 函数</p>
<ul>
<li>80 位置开始是一条 5 字节的指令码，80 位置的一个字节表示指令类型，81～84 位置表示 4 字节的偏移地址，当前全都是 0</li>
<li>OFFSET 为 0x81 的重定位入口类型为 <code>R_X86_64_PC32</code>，相关信息为 <code>__gai_sigqueue-0x0000000000000004</code>，等同于在链接阶段由链接器修正 81 位置开始的 4 字节偏移地址</li>
<li>假设最终 <code>__gai_sigqueue@plt</code> 被装载到地址 a，<code>__gai_notify_only()</code> 被装载到地址 b，则偏移地址被修正为 a - (0x85 - 0x50 + b)</li>
<li>1c1: 行的偏移地址修正也是同理</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">objdump -d /usr/lib64/libanl.a</span><br><span class="line"></span><br><span class="line">gai_notify.o:     file format elf64-x86-64</span><br><span class="line">...</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">...</span><br><span class="line">0000000000000050 &lt;__gai_notify_only&gt;:</span><br><span class="line">...</span><br><span class="line">  80:   e8 00 00 00 00          callq  85 &lt;__gai_notify_only+0x35&gt;</span><br><span class="line">  85:   48 83 c4 50             add    <span class="variable">$0x50</span>,%rsp</span><br><span class="line">  89:   c1 f8 1f                sar    <span class="variable">$0x1f</span>,%eax</span><br><span class="line">  8c:   5b                      pop    %rbx</span><br><span class="line">...</span><br><span class="line">0000000000000120 &lt;__gai_notify&gt;:</span><br><span class="line">...</span><br><span class="line"> 1bd:   49 8b 34 24             mov    (%r12),%rsi</span><br><span class="line"> 1c1:   e8 00 00 00 00          callq  1c6 &lt;__gai_notify+0xa6&gt;</span><br><span class="line"> 1c6:   48 8b 7b 08             mov    0x8(%rbx),%rdi</span><br><span class="line"> 1ca:   eb b0                   jmp    17c &lt;__gai_notify+0x5c&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>排查函数调用关系可以得出符号被引入 TiFlash 的过程：</p>
<ul>
<li>libc.so：实现并对外导出 <code>__gai_sigqueue()</code> 函数，对应版本 <code>GLIBC_PRIVATE</code></li>
<li>libanl.a：<ul>
<li><code>gai_notify.o</code> 中 <code>__gai_notify()</code> 和 <code>__gai_notify_only()</code> 调用了 <code>__gai_sigqueue()</code></li>
<li><code>getaddrinfo_a.o</code> 中 <code>getaddrinfo_a()</code> 调用了 <code>__gai_notify_only()</code></li>
<li><code>gai_misc.o</code> 中 <code>handle_requests()</code> 调用了 <code>__gai_notify()</code></li>
</ul>
</li>
<li>TiFlash 代码中的 <code>poco</code> 模块调用了 <code>getaddrinfo_a()</code> 函数：<a target="_blank" rel="noopener" href="https://github.com/pingcap/poco/blob/e411ea34492bf26e76b4e4a03ff5813a0c779240/Net/src/DNS.cpp#L167">pingcap&#x2F;poco&#x2F;Net&#x2F;src&#x2F;DNS.cpp#L167</a></li>
<li>libanl.a 和 libc.so 被先后链接，<code>getaddrinfo_a</code> 被决议成本地符号，<code>__gai_sigqueue</code> 被决议成外部符号</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">nm -CD /lib64/libc.so.6</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">0000000000111a90 T __gai_sigqueue</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">nm /lib64/libanl.a</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">gai_notify.o:</span><br><span class="line">                 U free</span><br><span class="line">0000000000000120 T __gai_notify</span><br><span class="line">0000000000000050 T __gai_notify_only</span><br><span class="line">                 U __gai_sigqueue</span><br><span class="line">                 U malloc</span><br><span class="line">                 U pthread_attr_init</span><br><span class="line">                 U pthread_attr_setdetachstate</span><br><span class="line">                 U pthread_create</span><br><span class="line">                 U sigemptyset</span><br><span class="line">0000000000000000 W _.stapsdt.base</span><br><span class="line">...</span><br><span class="line">getaddrinfo_a.o:</span><br><span class="line">                 U errno</span><br><span class="line">                 U __gai_enqueue_request</span><br><span class="line">                 U __gai_notify_only</span><br><span class="line">                 U __gai_requests_mutex</span><br><span class="line">0000000000000000 T getaddrinfo_a</span><br><span class="line">                 U getpid</span><br><span class="line">                 U _GLOBAL_OFFSET_TABLE_</span><br><span class="line">                 U malloc</span><br><span class="line">                 U pthread_mutex_lock</span><br><span class="line">                 U pthread_mutex_unlock</span><br><span class="line">                 w pthread_setcancelstate</span><br><span class="line">...</span><br><span class="line">gai_misc.o:</span><br><span class="line">...</span><br><span class="line">0000000000000000 t handle_requests</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">nm -Cg ./tiflash</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">0000000007fa4330 T getaddrinfo_a</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>如何解决上述外部符号问题？</strong></p>
<p>a. 基于实际运行环境编译发布</p>
<ul>
<li>这是风险最小的方式，面向小众平台（例如苹果的 MacOS）发布可以选用这种方式快速解决兼容性问题，缺点是成本较高</li>
</ul>
<p>b. 将有风险的符号在本地实现</p>
<ul>
<li>例如 CK 的 glibc-compatibility 模块中 <a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/4dcbf3a5c5dfe1ccb2f47c025b8cb23ae71f1dd2/base/glibc-compatibility/glibc-compatibility.c#L18">glibc-compatibility.c#L18</a> 直接将 <code>__gai_sigqueue()</code> 函数代码在本地实现。参考 <a href="#Linux-%E9%9D%99%E6%80%81%E5%BA%93">Linux 静态库</a> 中介绍的链接器行为，只要链接 glibc-compatibility 先于 glibc，则最终符号表里用的就是本地实现的函数；</li>
<li>实际上 TiFlash 的代码里也有类似的实现 <a target="_blank" rel="noopener" href="https://github.com/pingcap/tiflash/tree/eaf1a4cf886d1d5a86d04ef14eff956778ab4911/libs/libglibc-compatibility">libglibc-compatibility</a>，但在 ARM 平台编译时不启用（尚未适配）。</li>
<li><strong>注意：如果程序用 <code>-static</code> 的模式编译（即链接 <code>/lib64/libc.a</code>），则要注意符号冲突。</strong><ul>
<li>例如本案例中 <code>__gai_sigqueue</code> 来自 <code>gai_sigqueue.o</code>，glibc 中该目标文件下没有定义导出其他符号，不会有影响</li>
<li>假如本地实现了 <code>getnssent_r.o</code> 的 <code>__nss_endent</code>，则需要同时实现 <code>__nss_getent_r</code> 和 <code>__nss_setent</code>。如果程序其他模块引用了 <code>__nss_getent_r</code> 并需要链接 <code>getnssent_r.o</code>，则容易引起符号冲突。</li>
</ul>
</li>
</ul>
<p>c. 利用 asm 显示地为函数指定 glibc 版本，这种方式需要把控好函数的入口，避免过度污染</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.symver __foo_old, foo@VER1</span><br><span class="line">.symver __foo_new, foo@@VER2</span><br><span class="line">.symver __bar_old, bar@@VER1</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<ul>
<li>例如下面的例子，通过编译参数强制将 <code>realpath()</code> 指定为 <code>GLIBC_2.2.5</code> 版本。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main6.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> REALPATH_HACK</span></span><br><span class="line">__asm__(<span class="string">&quot;.symver realpath,realpath@GLIBC_2.2.5&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* unresolved = <span class="string">&quot;/lib64&quot;</span>;</span><br><span class="line">    <span class="type">char</span> resolved[PATH_MAX+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">realpath</span>(unresolved, resolved))</span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, resolved);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clang++ main6.cpp -o main6 &amp;&amp; readelf -a  main6 | grep <span class="string">&#x27;realpath&#x27;</span></span><br><span class="line"></span><br><span class="line">000000203ae8  000400000007 R_X86_64_JUMP_SLO 0000000000000000 <span class="built_in">realpath</span>@GLIBC_2.3 + 0</span><br><span class="line">     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND <span class="built_in">realpath</span>@GLIBC_2.3 (3)</span><br><span class="line">    32: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND <span class="built_in">realpath</span></span><br><span class="line"></span><br><span class="line">clang++ main6.cpp -DREALPATH_HACK -o main6 &amp;&amp; readelf -a  main6 | grep <span class="string">&#x27;realpath&#x27;</span></span><br><span class="line"></span><br><span class="line">000000203ac8  000500000007 R_X86_64_JUMP_SLO 0000000000000000 <span class="built_in">realpath</span>@GLIBC_2.2.5 + 0</span><br><span class="line">     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND <span class="built_in">realpath</span>@GLIBC_2.2.5 (2)</span><br><span class="line">    33: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND <span class="built_in">realpath</span></span><br></pre></td></tr></table></figure>

<h2 id="动态库-or-静态库"><a href="#动态库-or-静态库" class="headerlink" title="动态库 or 静态库"></a>动态库 or 静态库</h2><h3 id="案例（7）"><a href="#案例（7）" class="headerlink" title="案例（7）"></a>案例（7）</h3><p><a href="#%E6%A1%88%E4%BE%8B%EF%BC%886%EF%BC%89">案例（6）</a> 中提到了 Rust 语言实现的动态库 <code>libtiflash_proxy.so</code>，为什么实现上要选择动态库而不是静态库？</p>
<h4 id="分析（7）"><a href="#分析（7）" class="headerlink" title="分析（7）"></a>分析（7）</h4><p>从开发者角度来说理想的模式是所有功能按模块拆分成库，开发调试时用动态库，打包发布时用静态库。对于大型工程而言，动态库可灵活替换带来的便利性不言而喻。</p>
<hr>
<p>涉及到跨语言交互的场景，符号冲突是一个不忽略的问题。Rust 关于符号处理的行为是：</p>
<ul>
<li>对于 <code>crate-type = [&quot;cdylib&quot;]</code> 类型的库，Rust 默认对外 <strong>隐藏符号</strong>，如果要以 C 语言的 ABI 标准对外导出函数需显式地指定其属性为 <code>#[no_mangle] pub unsafe extern &quot;C&quot;</code>，例如 <a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb-engine-ext/blob/794b9ee12d216cd66bce2da69794f2e5d96aac90/raftstore-proxy/src/lib.rs#L5-L8">print_raftstore_proxy_version 函数定义</a>。</li>
<li>对于 <code>#[crate_type = &quot;staticlib&quot;]</code> 类型的静态库，则是同其他语言一样默认导出符号。</li>
</ul>
<p>由于种种原因，tidb-engine-ext 需要同 TiKV 的代码栈保持基本同步。如果将 <a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb-engine-ext/blob/37c5e02754c6acc3b53d1d4e2cb1ad2108a60439/raftstore-proxy/Cargo.toml#L10">raftstore_proxy</a> 的类型改成 <code>#[crate_type = &quot;staticlib&quot;]</code>，编译得到 <code>libraftstore_proxy.a</code>，强制魔改下 TiFlash 的代码，让其链接这个静态库而非 <code>libtiflash_proxy.so</code>，可以看到多处链接时报错 <code>ld.lld: error: duplicate symbol</code>。报错的符号有 <code>__rust_drop_panic</code>，<code>rust_panic</code>，<code>grpc_set_ssl_roots_override_callback</code> 等，与 <code>libsymbolization.a</code>，<code>libgrpc.a</code> 这几个本地编译的静态库相冲突。虽然理论上有诸多办法可以解决（参考 <a href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98">静态库冲突问题</a>）但相对会增加心智负担。</p>
<p>使用动态库则相对简单，仅需把交互相关的接口定义好导出即可（同时也要避免符号污染）。对于开发者而言，对于不涉及接口格式的模块内改动，则不需要静态库那样全量编译。</p>
<p>根据上文的介绍，动态库装载时会进行符号绑定，所以在使用时有几点需要注意：</p>
<ul>
<li>与 TiKV 不同，tidb-engine-ext 不指定内存分配器（即令 <code>malloc</code>｜<code>free</code> 之类的内存管理接口被编译器决议成未定义符号），此举是为了保证同宿主进程兼容。例如 TiFlash 中使用了自定义的内存分配器 jemalloc，malloc｜free 之类的函数被决议成内部重载的版本，参照上文 <a href="#%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89">分析（1）</a> 的动态库装载过程，<code>libtiflash_proxy.so</code> 最终使用的是 TiFlash 主进程提供的内存分配器。如果 TiFlash 也不指定内存分配器，则最终使用的是 Glibc 相关库中的默认版本。</li>
<li>使用 tidb-engine-ext 时以下几个符号需要注意，不要有本地同名符号，以免载入动态库时这些函数被本地实现覆盖：<code>bz_internal_error</code> 由 <a target="_blank" rel="noopener" href="https://github.com/alexcrichton/bzip2-rs">bzip2-sys</a> 引入；<code>perf_signal_handler</code> 由 <a target="_blank" rel="noopener" href="https://github.com/tikv/pprof-rs">pprof-rs</a> 引入；<code>rust_eh_personality</code> 则是编译器的保留项；</li>
<li>如果本地同时引入了其他 Rust 环境，例如现在的 <code>libsymbolization.a</code>，则需要尽量保证这些环境使用的 Rust 版本一致，以免产生非预期的行为。</li>
</ul>
<p>尽管目前 <code>libtiflash_proxy.so</code> 是用的隐式加载的模式，但实际上核心的功能函数就只有 <code>run_raftstore_proxy_ffi</code>，动态库与宿主进程间交互的接口（主要是函数指针）通过这个入口相互注册，所以完全可以做到运行时加载。</p>
<ul>
<li>这种动态库设计方向，把接口封装到运行逻辑的上下文中而不是独立的函数，以此来支持热更新。当然缺点也是有的：一来是目前 tidb-engine-ext 面向的场景并不需要热更新，二来额外的封装造成接口函数调用多出些间接寻址开销（正常业务场景中可以忽略不计）。</li>
<li>运行时加载也可以解决潜在的动态库符号冲突问题，参考 <a href="#%E6%A1%88%E4%BE%8B%EF%BC%881%EF%BC%89">案例（1）</a>。</li>
</ul>
<h1 id="Linux-静态库"><a href="#Linux-静态库" class="headerlink" title="Linux 静态库"></a>Linux 静态库</h1><p>在软件开发体系中，把每个源代码模块独立地编译，然后按照需要 “组装” 起来，这个组装模块的过程就是链接（Linking）。链接器的工作主要是把指令对其他符号地址的引用加以修正。链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution，aka 符号绑定）和重定位（Relocation）等步骤。</p>
<p><strong>静态库可以看作是目标文件的合集，链接器链接静态库是以目标文件为基本单位的</strong>。例如一个简单的 <code>hello world</code> 程序引用了外部符号 <code>printf</code> 并静态链接 <code>/lib64/libc.a</code>，那么链接器处理 <code>printf</code> 时，会先链接 <code>/lib64/libc.a</code> 中实现该函数的目标文件 <code>printf.o</code>，将其整个纳入到输出目标中（也包括其他可能对该程序无用的函数），该目标文件还引用了外部符号 <code>stdout</code> 和 <code>vfprintf</code>，则这些符号又会继续被处理，直到决议和重定位完所有符号。</p>
<ul>
<li>理论上按照层次化｜模块化存储和组织源代码有很多好处，比如代码更容易理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。</li>
</ul>
<h2 id="静态库冲突问题"><a href="#静态库冲突问题" class="headerlink" title="静态库冲突问题"></a>静态库冲突问题</h2><p><a href="#%E5%88%86%E6%9E%90%EF%BC%887%EF%BC%89">分析（7）</a> 中提到了 TiFlash 静态链接 <code>libraftstore_proxy.a</code> 时遇到符号冲突的问题。本章节介绍几种解决静态库符号冲突的方法。</p>
<h3 id="案例（8）"><a href="#案例（8）" class="headerlink" title="案例（8）"></a>案例（8）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test7_1.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">goo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">11</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test7_2.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">koo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">22</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test7_3.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main7.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">koo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">goo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, <span class="built_in">foo</span>(), <span class="built_in">koo</span>(), <span class="built_in">goo</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 个静态库内同时实现了 <code>foo</code> 函数和其他自定义函数，<code>main7</code> 编译链接 <code>libtest7_2.a</code>、<code>libtest7_3.a</code> 和 <code>libtest7_1.a</code>，最后报错 <code>duplicate symbol: foo()</code></p>
<ul>
<li>为什么会产生 <code>duplicate symbol</code> ？</li>
<li><code>libtest7_3.a</code> 中也实现了 <code>foo</code> 函数，为什么没有出现在报错信息里？</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clang++ -c test7_1.cpp -o test7_1.o &amp;&amp; ar -cr libtest7_1.a test7_1.o</span><br><span class="line">clang++ -c test7_2.cpp -o test7_2.o &amp;&amp; ar -cr libtest7_2.a test7_2.o</span><br><span class="line">clang++ -c test7_3.cpp -o test7_3.o &amp;&amp; ar -cr libtest7_3.a test7_3.o</span><br><span class="line">clang++ main7.cpp -L./ -ltest7_2 -ltest7_3 -ltest7_1 -o main7 -static --verbose &amp;&amp; ./main7</span><br><span class="line"></span><br><span class="line">ld.lld: error: duplicate symbol: foo()</span><br><span class="line">&gt;&gt;&gt; defined at test7_2.cpp</span><br><span class="line">&gt;&gt;&gt;            test7_2.o:(foo()) <span class="keyword">in</span> archive ./libtest7_2.a</span><br><span class="line">&gt;&gt;&gt; defined at test7_1.cpp</span><br><span class="line">&gt;&gt;&gt;            test7_1.o:(.text+0x0) <span class="keyword">in</span> archive ./libtest7_1.a</span><br><span class="line">clang-13: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>

<h4 id="分析（8）"><a href="#分析（8）" class="headerlink" title="分析（8）"></a>分析（8）</h4><p>链接过程详解：</p>
<ul>
<li>每个模块都是独立编译的，编译器在编译 main7.cpp 时并不知道其引用的几个函数（包括 <code>printf</code>）的地址，所以生成的目标文件（此处为临时文件，例如 <code>/tmp/main7-6aa576.o</code>）的符号表中包含未定义类型的符号 <code>_Z3foov</code>，<code>_Z3koov</code>，<code>_Z3goov</code>，<code>printf</code>。</li>
<li>根据链接参数的顺序，首先被载入的是 <code>/tmp/main7-6aa576.o</code>，链接器其纳入输出目标，<code>_Z3foov</code>，<code>_Z3koov</code>，<code>_Z3goov</code>，<code>printf</code> 则是待决议。</li>
<li>链接器从 <code>libtest7_2.a</code> 的 <code>test7_2.o</code> 模块的符号表中找到待决议的符号 <code>_Z3foov</code> 和 <code>_Z3koov</code>，纳入该目标文件并完成重定位。还剩下 <code>_Z3goov</code>，<code>printf</code>。</li>
<li>链接器从 <code>libtest7_3.a</code> 各个模块的符号表中找不到待决议的符号，则直接跳过。</li>
<li>链接器从 <code>libtest7_1.a</code> 的 <code>test7_1.o</code> 模块的符号表中找到待决议的符号 <code>_Z3goov</code>，但在链接模块 <code>test7_1.o</code> 过程中发现符号 <code>_Z3foov</code> 已经被绑定，则对外报错。</li>
</ul>
<h4 id="解决方案（8）"><a href="#解决方案（8）" class="headerlink" title="解决方案（8）"></a>解决方案（8）</h4><h5 id="删除冲突的符号"><a href="#删除冲突的符号" class="headerlink" title="删除冲突的符号"></a>删除冲突的符号</h5><ul>
<li>如果可以修改源代码，这是最简单有效的方法。</li>
<li>如果没有源码，可以借助工具 <code>llvm-ar -x lib__.a</code> 拆分成独立的目标文件，按需选择并删除后，再重新打包生成构静态库<ul>
<li>需要注意的是删除的最小单位是目标文件，如果因此删除了有用的符号，则会导致后续实际使用时报错 <code>undefined symbol</code>。</li>
</ul>
</li>
</ul>
<h5 id="修改符号名称"><a href="#修改符号名称" class="headerlink" title="修改符号名称"></a>修改符号名称</h5><ul>
<li>如果可以修改源代码则相对简单。</li>
<li>如果没有源码，可借助工具 <code>llvm-objcopy --redefine-sym &lt;old&gt;=&lt;new&gt; lib__.a</code>，直接修改符号名称<ul>
<li>缺点：实际使用修改后的静态库时，需要适配新符号。</li>
</ul>
</li>
</ul>
<h5 id="修改冲突符号的类型"><a href="#修改冲突符号的类型" class="headerlink" title="修改冲突符号的类型"></a>修改冲突符号的类型</h5><ul>
<li>将冲突符号的类型由 <code>GLOBAL</code> 修改为 <code>LOCAL</code>。</li>
<li>为了避免静态库内其他目标文件无法链接被修改的符号，将静态重构成单个目标文件的结构<ul>
<li>缺点：只能全量链接整个库，会增大程序体积</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test7_4.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">soo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">foo</span>();&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">clang++ -c test7_4.cpp -o test7_4.o</span><br><span class="line">ld.lld -r test7_1.o test7_4.o -o test7_1_4.o</span><br><span class="line">nm test7_1_4.o</span><br><span class="line"></span><br><span class="line">0000000000000000 T _Z3foov</span><br><span class="line">0000000000000010 T _Z3goov</span><br><span class="line">0000000000000020 T _Z3soov</span><br><span class="line"></span><br><span class="line">llvm-objcopy --localize-symbol=<span class="string">&quot;_Z3foov&quot;</span> ./test7_1_4.o</span><br><span class="line">nm test7_1_4.o</span><br><span class="line"></span><br><span class="line">0000000000000000 t _Z3foov</span><br><span class="line">0000000000000010 T _Z3goov</span><br><span class="line">0000000000000020 T _Z3soov</span><br><span class="line"></span><br><span class="line">ar -cr libtest7_1_4.a  test7_1_4.o</span><br><span class="line">clang++ main7.cpp -L./ -ltest7_2 -ltest7_1_4 -o main7 -static --verbose </span><br></pre></td></tr></table></figure>

<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>未完待续</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/PingCAP/" rel="tag"># PingCAP</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Compiler/" rel="tag"># Compiler</a>
              <a href="/tags/System/" rel="tag"># System</a>
              <a href="/tags/FileSystem/" rel="tag"># FileSystem</a>
              <a href="/tags/DynamicLibrary/" rel="tag"># DynamicLibrary</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/12/21/pingcap/tiflash-distributed-storage-and-transaction-system/" rel="prev" title="TiFlash 分布式存储 & 事务体系架构">
                  <i class="fa fa-chevron-left"></i> TiFlash 分布式存储 & 事务体系架构
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/01/ProjectManagement/tiflash-open-source/" rel="next" title="TiFlash 项目开源历程">
                  TiFlash 项目开源历程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TONG, Zhigao</span>
</div>

    </div>
  </footer>

  
  <script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/lib/hexo-generator-searchdb/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
